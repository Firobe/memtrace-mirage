/* CTF 1.8 */
/* Format specification for Memtrace v001 */

typealias integer {size = 8;}  := uint8;
typealias integer {size = 16;} := uint16;
typealias integer {size = 32;} := uint32;
typealias integer {size = 64;} := uint64;
typealias integer {size = 8; signed = true;}  := int8;
typealias integer {size = 16; signed = true;} := int16;
typealias integer {size = 32; signed = true;} := int32;
typealias floating_point {exp_dig = 11;mant_dig = 53;align = 8;} := float64;


typealias struct {
  enum : uint8
    { u8 = 0...252, u16 = 253, u32 = 254, u64 = 255 } tag;
  variant <tag> {
    struct {} u8;
    uint16 u16;
    uint32 u32;
    uint64 u64;
  } value;
} := vint;

clock {
  name = clk;
  freq = 1000000; /* microsecs */
  offset_s = 0;
};

typealias integer {
  size = 64;
  map = clock.clk.value;
} := clk64;

trace {
  major = 1;
  minor = 8;
  byte_order = le;
  packet.header := struct { uint32 magic; };
};

stream {
  packet.context := struct {
    uint32 packet_size;
    clk64 timestamp_begin;
    clk64 timestamp_end;
    uint32 flush_duration;
    uint16 version;
    uint64 pid;

    uint16 cache_verify_ix;
    uint16 cache_verify_pred;
    uint64 cache_verify_val;
    uint64 alloc_id_begin;
    uint64 alloc_id_end;
  };
  event.header := struct {
    integer {size=25; align=1; signed=false; map=clock.clk.value;} timestamp;
    integer {size=7; align=1; signed=false;} id;
  };
};

event {
  id = 0;
  name = "trace_info";
  fields := struct {
    float64 sample_rate;
    uint8 word_size;
    string executable_name;
    string host_name;
    string ocaml_runtime_params;
    uint64 pid;
  };
};

typealias struct {
  integer {size=20; align=1; signed=false;} line;
  integer {size=8; align=1; signed=false;} start_char;
  integer {size=10; align=1; signed=false;} end_char;
  enum : integer {size=5; align=1; signed=false;}
    { mtf = 0...30, new = 31 } filename;
  enum : integer {size=5; align=1; signed=false;}
    { mtf = 0...30, new = 31 } defname;
  variant <filename> {
    struct {} mtf;
    string new;
  } opt_filename;
  variant <defname> {
    struct {} mtf;
    string new;
  } opt_defname;
} := location;

event {
  id = 1;
  name = "location";
  fields := struct {
    uint64 code;
    uint8 nlocs;
    location locs[nlocs];
  };
};

typealias struct {
  enum : integer {size=1; align=1; signed=false;} { hit = 0, miss = 1 } tag;
  integer {size=15; align=1; signed=false;} cache_bucket;
  variant <tag> {
    uint64 miss;
    uint8 hit;
  } v;
} := backtrace_code;

event {
  id = 2;
  name = "alloc";
  fields := struct {
    vint length;
    vint samples;
    uint8 is_major;
    vint common_prefix; /* number of slots shared by previous alloc */
    uint16 new_suffix; /* number of new slots */
    backtrace_code backtrace[new_suffix];
  };
};

event {
  id = 3;
  name = "promote";
  fields := struct {
    vint obj_id_delta;
  };
};

event {
  id = 4;
  name = "collect";
  fields := struct {
    vint obj_id_delta;
  };
};

